For class names we use CamelCase format.
Class is an object in Python.

class Person:
    pass

print(type(Person)) # <class 'type'>

To check if object instance of a class use the isinstance function:
print(isinstance(person, Person)) # true




You can initialize INSTANCE ATTIBUTES in a constructor. The first parameter always should be
a self(it can has another name but usually it is self), that is an object.

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
		
person = Person('Tom', '20')
print(person.name)
print(person.age)

You can add instance attibute to the object in any moment.
person.test = 7
print(person.test)

You can set new value to an instance attibute.
person.name = 'Ted'

You can delete instance attibute:
del person1.name
print(person1.name) #error



You can define INSTANCE METHODS in a class. First parameter should be self. You invoke this method without this parameter.
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def sayHello(self):
        print(f'Hi! My name is {self.name}')
	
	def saySomething(self, str):
        print(str)



You can define CLASS ATTIBUTES. It will be shared by all instances of the class. You should define it in a class:

class Person:
    counter = 0 # class attribute
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
        Person.counter += 1 # You should use class here to get counter`
    
    def sayHi(self):
        print(f'Hi, my name is {self.name}')


person1 = Person('Tom', 20)
person2 = Person('Jhon', 21)

# You can get counter value using class or object`
print(Person.counter)
print(person1.counter)



You can define CLASS METHOD. It will be shared by all instances of the class. You should use decorator @classmethod for this. You 
can use this method with class or object. Python passes object of class into class method.

class Person:
    counter = 0
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
        Person.counter += 1
    
    def say_hi(self):
        print(f'Hi, my name is {self.name}')

    @classmethod
    def create_anonymous(cls): # cls - class object
        return Person('anonymous', 22)


person1 = Person('Tom', 20)

anonymous1 = Person.create_anonymous() # use with class
anonynous2 = person1.create_anonymous() # use with object



You also can define STATIC METHOD. It is not bounded to class or object. It is usually used to group logically related function in class.
Note: but you can get it from class or object.

class TemperatureConverter:
    @staticmethod
    def celsius_to_fahrenheit(c):
        return 9 * c / 5 + 32

    @staticmethod
    def fahrenheit_to_celsius(f):
        return 5 * (f - 32) / 9    

temperature_converter = TemperatureConverter()
t1 = temperature_converter.celsius_to_fahrenheit(1)
t2 = TemperatureConverter.celsius_to_fahrenheit(1)



You can define string representation of object with a __str__ method.

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __str__(self):
        return f'My name is {self.name}' 

person = Person('Tom', 20)
print(person) # 'My name is Tom'







